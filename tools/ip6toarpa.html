
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IPv6 → ip6.arpa 反向域名转换器</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa4b2;--accent:#60a5fa}
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
    body{background:linear-gradient(180deg,#071023 0%, #071a2b 100%);color:#e6eef8;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{width:860px;max-width:100%;background:var(--card);border-radius:12px;padding:20px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    h1{margin:0 0 8px;font-size:20px}
    p.lead{margin:0 0 18px;color:var(--muted)}
    label{display:block;margin-top:10px;color:var(--muted);font-size:13px}
    input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:15px}
    .row{display:flex;gap:12px;margin-top:12px}
    .row > *{flex:1}
    button{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;color:#04203a;font-weight:600;cursor:pointer}
    pre{background:#021226;padding:12px;border-radius:8px;overflow:auto;margin-top:12px;color:#bfe6ff}
    .small{font-size:13px;color:var(--muted)}
    .error{color:#ffb4b4;margin-top:8px}
    footer{margin-top:14px;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="card">
    <h1>IPv6 → ip6.arpa 反向域名转换器</h1>
    <p class="lead">输入 IPv6 地址或带前缀的网络（如 <code>2001:470:5808::/48</code>），自动生成反向域名。</p>

    <label for="ipv6">IPv6 地址或前缀</label>
    <input id="ipv6" type="text" placeholder="例如：2001:470:5808::/48 或 2001:470:6f:10::/64 或 2001:db8::1" />

    <div class="row">
      <button id="convert">转换</button>
      <button id="copy">复制结果</button>
    </div>

    <div id="err" class="error" role="status" aria-live="polite"></div>

    <label class="small">生成的反向域名</label>
    <pre id="out">（点击“转换”查看结果）</pre>

    <footer>提示：输入带前缀的网络（/0–/128）时，将自动输出对应的反向区域名；输入完整 IPv6 地址时，则输出完整 PTR 名称。</footer>
  </div>

  <script>
    function expandIPv6(addr) {
      if (!addr || typeof addr !== 'string') return null;
      addr = addr.trim();
      let zoneIndex = addr.indexOf('%');
      if (zoneIndex !== -1) addr = addr.slice(0, zoneIndex);

      const ipv4Match = addr.match(/(\d+\.\d+\.\d+\.\d+)$/);
      let ipv4Tail = null;
      if (ipv4Match) {
        ipv4Tail = ipv4Match[1];
        addr = addr.slice(0, addr.length - ipv4Tail.length);
        const parts = ipv4Tail.split('.').map(n=>parseInt(n,10));
        if (parts.length===4 && parts.every(p=>p>=0 && p<=255)) {
          const hi = ((parts[0]<<8) | parts[1]).toString(16);
          const lo = ((parts[2]<<8) | parts[3]).toString(16);
          addr = addr + hi + ':' + lo;
        } else return null;
      }

      if (addr.indexOf('::') !== addr.lastIndexOf('::')) return null;

      let parts = [];
      if (addr.includes('::')) {
        const [left, right] = addr.split('::');
        const leftParts = left ? left.split(':').filter(Boolean) : [];
        const rightParts = right ? right.split(':').filter(Boolean) : [];
        const missing = 8 - (leftParts.length + rightParts.length);
        if (missing < 0) return null;
        parts = [...leftParts, ...Array(missing).fill('0'), ...rightParts];
      } else {
        parts = addr.split(':').filter(Boolean);
        if (parts.length !== 8) {
          if (parts.length < 8) {
            parts = parts.concat(Array(8 - parts.length).fill('0'));
          } else return null;
        }
      }

      const norm = parts.map(p => {
        if (!/^[0-9a-fA-F]{1,4}$/.test(p)) return null;
        return p.toLowerCase().padStart(4,'0');
      });
      if (norm.some(x=>x===null)) return null;
      return norm.join('');
    }

    function toIp6Arpa(hex32, nibbles) {
      if (!hex32 || hex32.length !== 32) return null;
      if (nibbles < 1 || nibbles > 32) return null;
      const used = hex32.slice(0, nibbles);
      const rev = used.split('').reverse().join('.');
      return rev + '.ip6.arpa';
    }

    function prefixToNibbles(prefixLen) {
      return Math.floor(prefixLen/4);
    }

    document.getElementById('convert').addEventListener('click', ()=>{
      const inputRaw = document.getElementById('ipv6').value.trim();
      const err = document.getElementById('err');
      const out = document.getElementById('out');
      err.textContent=''; out.textContent='';

      if (!inputRaw) { err.textContent='请输入 IPv6 地址或前缀。'; return; }

      let address = inputRaw;
      let prefixLen = null;
      if (inputRaw.includes('/')) {
        const [a, p] = inputRaw.split('/');
        address = a;
        prefixLen = parseInt(p,10);
        if (isNaN(prefixLen) || prefixLen < 0 || prefixLen > 128) {
          err.textContent='前缀长度无效，应为 0–128。';
          return;
        }
      }

      const expanded = expandIPv6(address);
      if (!expanded) {
        err.textContent = '无法解析该 IPv6 地址，请检查输入格式。';
        return;
      }

      let nibbles;
      if (prefixLen !== null) {
        nibbles = prefixToNibbles(prefixLen);
        if (prefixLen % 4 !== 0) {
          err.textContent = `注意：前缀长度 /${prefixLen} 不是4的倍数，结果已退化为 /${nibbles*4} 对应的反向区域。`;
        }
      } else {
        nibbles = 32; // 默认完整 PTR
      }

      if (nibbles === 0) {
        err.textContent = '前缀太短，不能生成反向域名。';
        return;
      }

      const result = toIp6Arpa(expanded, nibbles);
      if (!result) {
        err.textContent = '生成失败（内部错误）';
        return;
      }
      out.textContent = result;
    });

    document.getElementById('copy').addEventListener('click', async ()=>{
      const out = document.getElementById('out').textContent.trim();
      const err = document.getElementById('err'); err.textContent='';
      if (!out) { err.textContent='先点击“转换”生成结果。'; return; }
      try { await navigator.clipboard.writeText(out); err.textContent='已复制到剪贴板。'; }
      catch(e){ err.textContent='复制失败：' + (e.message || e); }
    });
  </script>
</body>
</html>
