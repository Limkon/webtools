<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èŠ‚ç‚¹é…ç½®è½¬æ¢å™¨</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            margin: auto;
        }
        h1 {
            color: #0056b3;
            text-align: center;
            margin-bottom: 25px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        textarea {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            min-height: 150px;
            box-sizing: border-box;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            flex-grow: 1;
            max-width: 150px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        pre {
            background-color: #eee;
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            border: 1px dashed #ccc;
        }
        .error {
            color: red;
            margin-top: 10px;
            text-align: center;
            white-space: pre-wrap;
        }
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
            margin-bottom: 15px;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            font-size: 17px;
            max-width: none;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #ccc;
        }
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>èŠ‚ç‚¹é…ç½®è½¬æ¢å™¨</h1>

        <div class="tab">
            <button class="tablinks active" onclick="openTab(event, 'forward')">æ­£å‘è½¬æ¢</button>
            <button class="tablinks" onclick="openTab(event, 'reverse')">åå‘è½¬æ¢</button>
        </div>

        <div id="forward" class="tabcontent" style="display: block;">
            <label for="nodeInput">è¯·è¾“å…¥èŠ‚ç‚¹ä¿¡æ¯ (æ¯è¡Œä¸€ä¸ª):</label>
            <textarea id="nodeInput"></textarea>

            <div class="button-group">
                <button onclick="convertNodes()">è½¬æ¢</button>
                <button id="saveButton" onclick="saveConfig()" disabled>ä¿å­˜ä¸º config.json</button>
            </div>

            <label for="outputConfig">ç”Ÿæˆçš„é…ç½®æ–‡ä»¶:</label>
            <textarea id="outputConfig" readonly></textarea>
        </div>

        <div id="reverse" class="tabcontent">
            <label for="configInput">è¯·è¾“å…¥ config.json å†…å®¹:</label>
            <textarea id="configInput"></textarea>

            <div class="button-group">
                <button onclick="reverseConvert()">åå‘è½¬æ¢</button>
                <button id="saveNodesButton" onclick="saveNodes()" disabled>ä¿å­˜ä¸º nodes.txt</button>
            </div>

            <label for="outputNodes">ç”Ÿæˆçš„èŠ‚ç‚¹ä¿¡æ¯:</label>
            <textarea id="outputNodes" readonly></textarea>
        </div>

        <p class="error" id="errorMessage"></p>
    </div>

    <script>
        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        // å®Œå…¨æœ¬åœ°åŒ–çš„ Base64 ç¼–ç å‡½æ•°ï¼Œæ”¯æŒ UTF-8
        function base64Encode(str) {
            try {
                const encoder = new TextEncoder('utf-8');
                const bytes = encoder.encode(str);
                let binary = '';
                bytes.forEach((byte) => {
                    binary += String.fromCharCode(byte);
                });
                return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
            } catch (e) {
                console.error("Base64 encoding error:", e);
                return null;
            }
        }

        // å®Œå…¨æœ¬åœ°åŒ–çš„ Base64 è§£ç å‡½æ•°ï¼Œæ”¯æŒ UTF-8
        function base64Decode(str) {
            try {
                str = str.replace(/-/g, '+').replace(/_/g, '/');
                while (str.length % 4) {
                    str += '=';
                }
                const binary_string = atob(str);
                const len = binary_string.length;
                const bytes = new Uint8Array(new ArrayBuffer(len));
                for (let i = 0; i < len; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                const decoder = new TextDecoder('utf-8');
                return decoder.decode(bytes);
            } catch (e) {
                console.error("Base64 decoding error:", e);
                return null;
            }
        }

        function parseUrl(url) {
            try {
                const protocol = url.split('://')[0].toLowerCase();

                // VMESS
                if (protocol === 'vmess') {
                    const base64Str = url.replace('vmess://', '').trim();
                    const decoded = base64Decode(base64Str);
                    if (!decoded) {
                        throw new Error("VMess base64 decoding failed.");
                    }
                    const vmessObj = JSON.parse(decoded);
                    return {
                        type: protocol,
                        server: vmessObj.add,
                        port: vmessObj.port,
                        uuid: vmessObj.id,
                        net: vmessObj.net,
                        path: vmessObj.path,
                        tls: vmessObj.tls,
                        host: vmessObj.host,
                        ps: vmessObj.ps,
                        sni: vmessObj.sni,
                        scy: vmessObj.scy
                    };
                }

                // HYSTERIA2
                if (protocol === 'hysteria2') {
                    const u = new URL(url);
                    const params = Object.fromEntries(u.searchParams.entries());
                    return {
                        type: 'hysteria2',
                        server: u.hostname,
                        port: parseInt(u.port || '443', 10),
                        password: u.username,
                        tag: decodeURIComponent(u.hash.replace('#', '')) || u.hostname,
                        insecure: params.insecure === '1',
                        sni: params.sni,
                        obfs: params.obfs,
                        up: params.up,
                        down: params.down,
                        alpn: params.alpn,
                        pinSHA256: params.pinSHA256,
                        ca: params.ca,
                        params: params // Keep all params
                    };
                }

                // VLESS / TROJAN
                if (protocol === 'vless' || protocol === 'trojan') {
                    const urlWithoutProtocol = url.substring(url.indexOf('://') + 3);
                    const hashIndex = urlWithoutProtocol.indexOf('#');
                    const coreAndParams = hashIndex !== -1 ? urlWithoutProtocol.substring(0, hashIndex) : urlWithoutProtocol;
                    const hashPart = hashIndex !== -1 ? decodeURIComponent(urlWithoutProtocol.substring(hashIndex + 1)) : '';

                    let userInfo = '';
                    let hostPortPathQueryString = coreAndParams;

                    const atIndex = coreAndParams.indexOf('@');
                    if (atIndex === -1) {
                        throw new Error(`Invalid ${protocol} URL: No user info found.`);
                    }
                    userInfo = coreAndParams.substring(0, atIndex);
                    hostPortPathQueryString = coreAndParams.substring(atIndex + 1);

                    let host = '';
                    let port = '';
                    let path = '';
                    let queryParams = {};

                    // Try using URL for parsing
                    const tempUrlForParsing = `http://${hostPortPathQueryString}`;
                    try {
                        const parsedTempUrl = new URL(tempUrlForParsing);
                        host = parsedTempUrl.hostname;
                        port = parsedTempUrl.port;
                        path = parsedTempUrl.pathname;
                        queryParams = Object.fromEntries(parsedTempUrl.searchParams.entries());
                    } catch (e) {
                        console.error("Failed to parse with URL constructor:", tempUrlForParsing, e);
                        // Manual fallback
                        const parts = hostPortPathQueryString.split('/');
                        const hostPort = parts[0];
                        host = hostPort.split(':')[0];
                        port = hostPort.split(':')[1] || '';
                        path = '/' + parts.slice(1).join('/').split('?')[0] || '/';
                        const queryString = parts.slice(1).join('/').split('?')[1] || '';
                        if (queryString) {
                            queryString.split('&').forEach(param => {
                                const [key, value] = param.split('=');
                                if (key) {
                                    queryParams[key] = value ? decodeURIComponent(value.replace(/\+/g, ' ')) : '';
                                }
                            });
                        }
                    }

                    // Prioritize 'path' from query params if present
                    const finalPath = queryParams.path ? decodeURIComponent(queryParams.path) : (path === '/' ? '' : path);

                    const finalPort = port ? parseInt(port, 10) : (queryParams.security === 'tls' ? 443 : 80);

                    // Ensure UUID is properly set for VLESS
                    const uuid = protocol === 'vless' ? userInfo : undefined;
                    if (protocol === 'vless' && !uuid) {
                        throw new Error("VLESS UUID is empty or missing.");
                    }

                    return {
                        type: protocol,
                        uuid: uuid, // Explicitly set for VLESS
                        password: protocol === 'trojan' ? userInfo : undefined, // For Trojan
                        server: host,
                        port: finalPort,
                        path: finalPath,
                        params: queryParams,
                        tag: hashPart || host
                    };
                }

            } catch (e) {
                console.error("Error parsing URL:", url, e);
                return null;
            }
            return null;
        }

        // --- å‡½æ•°å·²æ›´æ–° (åŒ¹é… config.json ç»“æ„) ---
        function convertNodes() {
            const nodeInput = document.getElementById('nodeInput').value;
            const outputConfig = document.getElementById('outputConfig');
            const errorMessage = document.getElementById('errorMessage');
            const saveButton = document.getElementById('saveButton');

            errorMessage.textContent = '';
            outputConfig.value = '';
            saveButton.disabled = true;

            const nodeUrls = nodeInput.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const parsedNodes = []; // å­˜å‚¨è§£æåçš„èŠ‚ç‚¹

            nodeUrls.forEach(url => {
                const parsed = parseUrl(url);
                if (!parsed) {
                    errorMessage.textContent += `æ— æ³•è§£æèŠ‚ç‚¹: ${url}\n`;
                    return;
                }

                if (parsed.type === 'hysteria2') {
                    // --- é€»è¾‘æ›´æ–°ï¼šæ·»åŠ  hysteria2 çš„ tag å”¯ä¸€æ€§æ£€æŸ¥ ---
                    let tag = (parsed.tag || parsed.server).replace(/[^a-zA-Z0-9.\-_]/g, '_');
                    const baseTag = tag;
                    let count = 1;
                    while (parsedNodes.some(n => n.tag === tag)) {
                        tag = `${baseTag}_${count++}`;
                    }
                    // --- é€»è¾‘æ›´æ–°ç»“æŸ ---

                    const hysteria2Outbound = {
                        type: 'hysteria2',
                        tag: tag, // ä½¿ç”¨ç¡®ä¿å”¯ä¸€çš„ tag
                        server: parsed.server,
                        server_port: parsed.port,
                        password: parsed.password
                    };

                    // TLS configuration
                    hysteria2Outbound.tls = {
                        enabled: true,
                        insecure: parsed.insecure,
                        server_name: parsed.sni,
                        alpn: parsed.alpn ? parsed.alpn.split(',') : undefined,
                        ca: parsed.ca ? atob(parsed.ca) : undefined, // Assuming ca is base64 encoded
                        pin_sha256: parsed.pinSHA256
                    };

                    // Obfs
                    if (parsed.obfs) {
                        hysteria2Outbound.obfs = {
                            type: 'salamander',
                            password: parsed.obfs
                        };
                    }

                    // Bandwidth
                    if (parsed.up) hysteria2Outbound.up_mbps = parseInt(parsed.up, 10);
                    if (parsed.down) hysteria2Outbound.down_mbps = parseInt(parsed.down, 10);

                    parsedNodes.push(hysteria2Outbound);
                } else if (parsed.type === 'vless') {
                    let tag = (parsed.tag || parsed.server).replace(/[^a-zA-Z0-9.\-_]/g, '_');
                    // ç¡®ä¿æ ‡ç­¾æ˜¯å”¯ä¸€çš„ï¼Œå¦‚æœå¤šä¸ªèŠ‚ç‚¹å¤‡æ³¨ç›¸åŒ
                    const baseTag = tag;
                    let count = 1;
                    while (parsedNodes.some(n => n.tag === tag)) {
                        tag = `${baseTag}_${count++}`;
                    }
                    const currentVlessTag = tag;


                    let tlsObj = {};
                    if (parsed.params.security === 'reality') {
                        tlsObj.enabled = true;
                        tlsObj.server_name = parsed.params.sni || parsed.server;
                        tlsObj.reality = { enabled: true, public_key: parsed.params.pbk, short_id: parsed.params.sid };
                        if (parsed.params.fp) tlsObj.utls = { enabled: true, fingerprint: parsed.params.fp };
                    } else if (parsed.params.security === 'tls') {
                        tlsObj.enabled = true;
                        tlsObj.server_name = parsed.params.sni || parsed.params.host || parsed.server;
                    }

                    let transportObj = null;
                    const transType = parsed.params.headerType && parsed.params.headerType !== 'none' ? parsed.params.headerType : (parsed.params.type || '');
                    if (transType && transType !== 'tcp') {
                        transportObj = {
                            type: transType,
                            path: parsed.path || '/',
                            headers: { Host: parsed.params.host || parsed.server }
                        };
                    }

                    parsedNodes.push({
                        type: 'vless',
                        tag: currentVlessTag,
                        server: parsed.server,
                        server_port: parsed.port,
                        uuid: parsed.uuid, // Use parsed.uuid instead of userInfo
                        flow: parsed.params.flow || '',
                        tls: tlsObj,
                        ...(transportObj ? { transport: transportObj } : {})
                    });
                } else if (parsed.type === 'trojan') {
                    let tag = (parsed.tag || parsed.server).replace(/[^a-zA-Z0-9.\-_]/g, '_');
                    // ç¡®ä¿æ ‡ç­¾æ˜¯å”¯ä¸€çš„
                    const baseTag = tag;
                    let count = 1;
                    while (parsedNodes.some(n => n.tag === tag)) {
                        tag = `${baseTag}_${count++}`;
                    }
                    const currentTrojanTag = tag;

                    let tlsObj = {};
                    if (parsed.params.security === 'tls') {
                        tlsObj.enabled = true;
                        tlsObj.server_name = parsed.params.sni || parsed.params.host || parsed.server;
                    }

                    let transportObj = null;
                    const transType = parsed.params.headerType && parsed.params.headerType !== 'none' ? parsed.params.headerType : (parsed.params.type || '');
                    if (transType && transType !== 'tcp') {
                        transportObj = {
                            type: transType,
                            path: parsed.path || '/',
                            headers: { Host: parsed.params.host || parsed.server }
                        };
                    }

                    parsedNodes.push({
                        type: 'trojan',
                        tag: currentTrojanTag,
                        server: parsed.server,
                        server_port: parsed.port,
                        password: parsed.password,
                        tls: tlsObj,
                        ...(transportObj ? { transport: transportObj } : {})
                    });
                } else if (parsed.type === 'vmess') {
                    let tag = (parsed.ps || parsed.server).replace(/[^a-zA-Z0-9.\-_]/g, '_');
                    // ç¡®ä¿æ ‡ç­¾æ˜¯å”¯ä¸€çš„
                    const baseTag = tag;
                    let count = 1;
                    while (parsedNodes.some(n => n.tag === tag)) {
                        tag = `${baseTag}_${count++}`;
                    }
                    const currentVmessTag = tag;

                    let tlsObj = null;
                    if (parsed.tls === 'tls') {
                        tlsObj = {
                            enabled: true,
                            server_name: parsed.sni || parsed.host || parsed.server
                        };
                    }

                    let transportObj = null;
                    const transType = parsed.net || 'tcp';
                    if (transType !== 'tcp') {
                        transportObj = {
                            type: transType,
                            path: parsed.path || '',
                            headers: { Host: parsed.host || parsed.server }
                        };
                    }

                    parsedNodes.push({
                        type: 'vmess',
                        tag: currentVmessTag,
                        server: parsed.server,
                        server_port: parseInt(parsed.port, 10),
                        uuid: parsed.uuid,
                        security: parsed.scy || 'auto',
                        ...(transportObj ? { transport: transportObj } : {}),
                        ...(tlsObj ? { tls: tlsObj } : {})
                    });
                }
            });

            if (parsedNodes.length === 0) {
                errorMessage.textContent = 'æ²¡æœ‰è§£æåˆ°æœ‰æ•ˆçš„èŠ‚ç‚¹ä¿¡æ¯ã€‚';
                return;
            }

            // --- åŒ¹é… config.json (æ–°ç»“æ„) çš„ç»“æ„ ---

            const nodeTags = parsedNodes.map(node => node.tag);
            
            // å®šä¹‰åŠŸèƒ½æ€§æ ‡ç­¾
            const tagAuto = "ğŸˆ è‡ªåŠ¨é€‰æ‹©";
            const tagDirect = "ğŸ¯ å…¨çƒç›´è¿";
            const tagBlock = "ğŸš« æ–­å¼€è¿æ¥";
            const tagFallback = "ğŸŸ æ¼ç½‘ä¹‹é±¼";
            const tagGlobal = "ğŸŒ GLOBAL";


            const config = {
                "log": {
                    "disabled": false,
                    "level": "error" // çº§åˆ«æ”¹ä¸º error
                },
                "experimental": { // åŒ¹é…æ–°ç»“æ„
                    "clash_api": {
                        "external_controller": "127.0.0.1:9090",
                        "external_ui": "ui",
                        "default_mode": "rule"
                    },
                    "cache_file": { // æ·»åŠ  cache_file
                        "enabled": true,
                        "path": "cache.db",
                        "store_fakeip": true,
                        "store_rdrc": true,  // æ ¹æ®ç¤ºä¾‹ config æ·»åŠ 
                        "rdrc_timeout": "7d" // æ ¹æ®ç¤ºä¾‹ config æ·»åŠ 
                    }
                },
                "inbounds": [
                    {
                        "tag": "http-in",
                        "type": "http",
                        "listen": "127.0.0.1",
                        "listen_port": 10809
                    }
                ],
                "outbounds": [
                    {
                        "type": "urltest", // æ›´æ”¹ä¸º urltest
                        "tag": tagAuto,
                        "url": "https://www.gstatic.com/generate_204",
                        "interval": "3m",
                        "tolerance": 150,
                        "interrupt_exist_connections": true, // æ ¹æ®ç¤ºä¾‹ config æ·»åŠ 
                        "outbounds": nodeTags // ä»…åŒ…å«èŠ‚ç‚¹ tags
                    },
                    {
                        "type": "direct",
                        "tag": tagDirect // æ›´æ–° tag
                    },
                    { // æ·»åŠ æ–° selector
                        "type": "selector",
                        "tag": tagFallback,
                        "interrupt_exist_connections": true, // æ ¹æ®ç¤ºä¾‹ config æ·»åŠ 
                        "outbounds": [tagAuto, tagDirect]
                    },
                    { // æ·»åŠ æ–° selector
                        "type": "selector",
                        "tag": tagGlobal,
                        "interrupt_exist_connections": true, // æ ¹æ®ç¤ºä¾‹ config æ·»åŠ 
                        "outbounds": [tagAuto, tagDirect, tagFallback]
                    },
                    {
                        "tag": tagBlock, // æ›´æ–° tag
                        "type": "block"
                    },
                    ...parsedNodes // å°†æ‰€æœ‰è§£æçš„èŠ‚ç‚¹å¯¹è±¡é™„åŠ åœ¨åé¢
                ],
                "route": {
                    "rules": [
                        // æ›´æ–°è§„åˆ™ä»¥åŒ¹é…æ–°é…ç½®
                        {
                            "domain_suffix": ["doh.pub", "cloudflare-dns.com"],
                            "outbound": tagDirect
                        },
                        {
                            "ip_cidr": ["119.29.29.29", "120.53.53.53"],
                            "outbound": tagDirect
                        },
                        { // æ ¹æ®ç¤ºä¾‹ config æ·»åŠ  Ads è§„åˆ™
                            "action": "reject", 
                            "rule_set": "Category-Ads"
                        },
                        {
                            "rule_set": ["GeoSite-Private", "GeoIP-Private"],
                            "outbound": tagDirect
                        },
                        {
                            "rule_set": ["GeoSite-CN", "GeoIP-CN"],
                            "outbound": tagDirect
                        }
                    ],
                    "final": tagAuto, // é»˜è®¤è·¯ç”±åˆ° urltest
                    "auto_detect_interface": true,
                    "find_process": true,
                    "rule_set": [ // æ·»åŠ  rule_set å®šä¹‰
                        { // æ ¹æ®ç¤ºä¾‹ config æ·»åŠ  Ads
                            "tag": "Category-Ads",
                            "type": "remote",
                            "url": "https://ghproxy.net/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/sing/geo/geosite/category-ads-all.srs",
                            "format": "binary",
                            "download_detour": tagDirect
                        },
                        {
                            "tag": "GeoIP-Private",
                            "type": "remote",
                            "url": "https://ghproxy.net/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/sing/geo/geoip/private.srs",
                            "format": "binary",
                            "download_detour": tagDirect
                        },
                        {
                            "tag": "GeoSite-Private",
                            "type": "remote",
                            "url": "https://ghproxy.net/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/sing/geo/geosite/private.srs",
                            "format": "binary",
                            "download_detour": tagDirect
                        },
                        {
                            "tag": "GeoIP-CN",
                            "type": "remote",
                            "url": "https://ghproxy.net/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/sing/geo/geoip/cn.srs",
                            "format": "binary",
                            "download_detour": tagDirect
                        },
                        {
                            "tag": "GeoSite-CN",
                            "type": "remote",
                            "url": "https://ghproxy.net/https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/sing/geo/geosite/cn.srs",
                            "format": "binary",
                            "download_detour": tagDirect
                        }
                    ]
                },
                "dns": {
                    "servers": [
                        // æ›´æ–° detour æ ‡ç­¾
                        { "tag": "dns_resolver-tx", "address": "119.29.29.29", "detour": tagDirect },
                        { "tag": "dns-direct-tx", "address": "https://doh.pub/dns-query", "address_resolver": "dns_resolver-tx", "detour": tagDirect },
                        { "tag": "dns-proxy-cf", "address": "https://cloudflare-dns.com/dns-query", "address_resolver": "dns_resolver-tx", "detour": tagAuto },
                        { "tag": "dns-block", "address": "rcode://refused" }
                    ],
                    "rules": [
                         // æ›´æ–°è§„åˆ™
                        {
                            "domain_suffix": ["visa.com.tw", "visa.com.sg", "visa.com", "abrdns.com", "doh.pub", "cloudflare-dns.com"], // æ ¹æ®ç¤ºä¾‹ config æ·»åŠ 
                            "server": "dns-direct-tx"
                        },
                        {
                            "rule_set": "GeoSite-CN",
                            "server": "dns-direct-tx"
                        }
                    ],
                    "client_subnet": "119.37.192.0", // æ·»åŠ  client_subnet
                    "strategy": "ipv4_only",
                    "final": "dns-proxy-cf"
                }
            };
            // --- ç»“æ„åŒ¹é…ç»“æŸ ---

            outputConfig.value = JSON.stringify(config, null, 2);
            saveButton.disabled = false;
        }

        // --- å‡½æ•°å·²æ›´æ–° (åŒ¹é… config.json ç»“æ„) ---
        function reverseConvert() {
            const configInput = document.getElementById('configInput').value;
            const outputNodes = document.getElementById('outputNodes');
            const errorMessage = document.getElementById('errorMessage');
            const saveNodesButton = document.getElementById('saveNodesButton');

            errorMessage.textContent = '';
            outputNodes.value = '';
            saveNodesButton.disabled = true;

            let config;
            try {
                config = JSON.parse(configInput);
            } catch (e) {
                errorMessage.textContent = 'æ— æ•ˆçš„ JSON é…ç½®ã€‚';
                return;
            }

            const outbounds = config.outbounds || [];
            const nodeUrls = [];

            outbounds.forEach(outbound => {
                const type = outbound.type;
                let url = '';

                // --- é€»è¾‘ä¿®æ”¹ ---
                // åªè½¬æ¢èŠ‚ç‚¹ï¼Œè·³è¿‡ selector, direct, block, ä»¥åŠæ–°å¢çš„ urltest
                if (type === 'selector' || type === 'direct' || type === 'block' || type === 'urltest') {
                    return; 
                }
                // --- é€»è¾‘ä¿®æ”¹ç»“æŸ ---

                if (type === 'hysteria2') {
                    let paramsStr = '';
                    if (outbound.tls) {
                        if (outbound.tls.insecure) paramsStr += `insecure=1&`;
                        if (outbound.tls.server_name) paramsStr += `sni=${encodeURIComponent(outbound.tls.server_name)}&`;
                        if (outbound.tls.alpn) paramsStr += `alpn=${encodeURIComponent(outbound.tls.alpn.join(','))}&`;
                        if (outbound.tls.ca) paramsStr += `ca=${btoa(outbound.tls.ca)}&`; // Base64 encode ca
                        if (outbound.tls.pin_sha256) paramsStr += `pinSHA256=${encodeURIComponent(outbound.tls.pin_sha256)}&`;
                    }
                    if (outbound.obfs) {
                        if (outbound.obfs.password) paramsStr += `obfs=${encodeURIComponent(outbound.obfs.password)}&`;
                    }
                    if (outbound.up_mbps) paramsStr += `up=${outbound.up_mbps}&`;
                    if (outbound.down_mbps) paramsStr += `down=${outbound.down_mbps}&`;

                    paramsStr = paramsStr.slice(0, -1); // Remove trailing &
                    url = `hysteria2://${outbound.password}@${outbound.server}:${outbound.server_port}${paramsStr ? '?' + paramsStr : ''}#${encodeURIComponent(outbound.tag)}`;
                } else if (type === 'vless') {
                    let paramsStr = '';
                    if (outbound.flow) paramsStr += `flow=${outbound.flow}&`;
                    let security = 'none';
                    let sni = '';
                    let pbk = '';
                    let sid = '';
                    let fp = '';
                    if (outbound.tls) {
                        if (outbound.tls.reality && outbound.tls.reality.enabled) {
                            security = 'reality';
                            sni = outbound.tls.server_name || '';
                            pbk = outbound.tls.reality.public_key || '';
                            sid = outbound.tls.reality.short_id || '';
                            if (outbound.tls.utls && outbound.tls.utls.enabled) {
                                fp = outbound.tls.utls.fingerprint || '';
                            }
                        } else if (outbound.tls.enabled) {
                            security = 'tls';
                            sni = outbound.tls.server_name || '';
                        }
                    }
                    if (security !== 'none') paramsStr += `security=${security}&`;
                    if (sni) paramsStr += `sni=${encodeURIComponent(sni)}&`;
                    if (pbk) paramsStr += `pbk=${encodeURIComponent(pbk)}&`;
                    if (sid) paramsStr += `sid=${encodeURIComponent(sid)}&`;
                    if (fp) paramsStr += `fp=${fp}&`;

                    let path = '/';
                    let host = outbound.server;
                    let transType = 'tcp';
                    let headerType = 'none';
                    if (outbound.transport) {
                        transType = outbound.transport.type || 'tcp';
                        path = outbound.transport.path || '/';
                        host = outbound.transport.headers && outbound.transport.headers.Host ? outbound.transport.headers.Host : host;
                        if (transType === 'http') headerType = 'http';
                    }
                    if (transType !== 'tcp') paramsStr += `type=${transType}&`;
                    if (headerType !== 'none') paramsStr += `headerType=${headerType}&`;
                    if (path !== '/' && path) paramsStr += `path=${encodeURIComponent(path)}&`; // ä¿®æ­£ï¼šç¡®ä¿ path å­˜åœ¨
                    if (host !== outbound.server && host) paramsStr += `host=${encodeURIComponent(host)}&`;

                    paramsStr = paramsStr.slice(0, -1); // Remove trailing &
                    url = `vless://${outbound.uuid}@${outbound.server}:${outbound.server_port}?${paramsStr}#${encodeURIComponent(outbound.tag)}`;
                } else if (type === 'trojan') {
                    let paramsStr = '';
                    let security = 'none';
                    let sni = '';
                    if (outbound.tls && outbound.tls.enabled) {
                        security = 'tls';
                        sni = outbound.tls.server_name || '';
                    }
                    if (security !== 'none') paramsStr += `security=${security}&`;
                    if (sni) paramsStr += `sni=${encodeURIComponent(sni)}&`;

                    let path = '/';
                    let host = outbound.server;
                    let transType = 'tcp';
                    let headerType = 'none';
                    if (outbound.transport) {
                        transType = outbound.transport.type || 'tcp';
                        path = outbound.transport.path || '/';
                        host = outbound.transport.headers && outbound.transport.headers.Host ? outbound.transport.headers.Host : host;
                        if (transType === 'http') headerType = 'http';
                    }
                    if (transType !== 'tcp') paramsStr += `type=${transType}&`;
                    if (headerType !== 'none') paramsStr += `headerType=${headerType}&`;
                    if (path !== '/' && path) paramsStr += `path=${encodeURIComponent(path)}&`; // ä¿®æ­£ï¼šç¡®ä¿ path å­˜åœ¨
                    if (host !== outbound.server && host) paramsStr += `host=${encodeURIComponent(host)}&`;

                    paramsStr = paramsStr.slice(0, -1);
                    url = `trojan://${outbound.password}@${outbound.server}:${outbound.server_port}?${paramsStr}#${encodeURIComponent(outbound.tag)}`;
                } else if (type === 'vmess') {
                    const vmessObj = {
                        v: '2',
                        ps: outbound.tag, // ä½¿ç”¨å®Œæ•´çš„ tag ä½œä¸º ps
                        add: outbound.server,
                        port: outbound.server_port.toString(),
                        id: outbound.uuid,
                        net: outbound.transport ? outbound.transport.type : 'tcp',
                        path: outbound.transport ? outbound.transport.path : '',
                        host: outbound.transport && outbound.transport.headers ? outbound.transport.headers.Host : '',
                        tls: outbound.tls && outbound.tls.enabled ? 'tls' : '',
                        sni: outbound.tls ? outbound.tls.server_name : '',
                        scy: outbound.security || 'auto'
                    };
                    const encoded = base64Encode(JSON.stringify(vmessObj));
                    if (encoded) {
                        url = `vmess://${encoded}`;
                    }
                }

                if (url) {
                    nodeUrls.push(url);
                }
            });

            if (nodeUrls.length === 0) {
                errorMessage.textContent = 'æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„ outbounds èŠ‚ç‚¹æ¥åå‘è½¬æ¢ã€‚';
                return;
            }

            outputNodes.value = nodeUrls.join('\n');
            saveNodesButton.disabled = false;
        }

        function saveConfig() {
            const configContent = document.getElementById('outputConfig').value;
            if (configContent) {
                const blob = new Blob([configContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'config.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else {
                document.getElementById('errorMessage').textContent = 'æ²¡æœ‰å†…å®¹å¯ä¾›ä¿å­˜ï¼Œè¯·å…ˆè½¬æ¢èŠ‚ç‚¹ã€‚';
            }
        }

        function saveNodes() {
            const nodesContent = document.getElementById('outputNodes').value;
            if (nodesContent) {
                const blob = new Blob([nodesContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'nodes.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } else {
                document.getElementById('errorMessage').textContent = 'æ²¡æœ‰å†…å®¹å¯ä¾›ä¿å­˜ï¼Œè¯·å…ˆåå‘è½¬æ¢ã€‚';
            }
        }
    </script>
</body>
</html>
