
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>文本隐写工具</title>
  <style>
    :root{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
    body{max-width:900px;margin:28px auto;padding:18px;background:#f7f8fb;color:#0b1220}
    h1{font-size:20px;margin-bottom:6px}
    label{display:block;margin-top:12px;font-weight:600}
    textarea,input,select{width:100%;box-sizing:border-box;padding:10px;margin-top:6px;border:1px solid #d6d9e6;border-radius:8px;background:white}
    button{margin-top:10px;padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:white;cursor:pointer}
    .row{display:flex;gap:8px}
    .small{font-size:13px;color:#46536a}
    .result{white-space:pre-wrap;background:#0b122033;padding:10px;border-radius:8px;margin-top:10px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .muted{color:#6b7280;font-size:13px}
  </style>
</head>
<body>
  <h1>文本隐写工具</h1>
  <p class="small">将任意秘密文本编码为零宽字符并隐藏在载体文本中。零宽字符肉眼不可见，可用于简单隐写演示。注意：此工具仅用于合法用途。</p>

  <label>载体文本（Carrier text）</label>
  <textarea id="carrier" rows="4" placeholder="在这里粘贴或输入载体文本（比如一段普通句子）"></textarea>

  <label>秘密文本（Secret message）</label>
  <textarea id="secret" rows="3" placeholder="要隐藏的文本"></textarea>

  <label>编码方式</label>
  <select id="method">
    <option value="append">尾部追加（Append payload to end of carrier）</option>
    <option value="interleave">字符插入（Interleave zeros after carrier characters）</option>
  </select>

  <div class="controls">
    <button id="encodeBtn">编码并生成隐写文本</button>
    <button id="decodeBtn" style="background:#10b981">尝试从载体中解码</button>
    <button id="copyBtn" style="background:#374151">复制输出</button>
    <button id="clearBtn" style="background:#ef4444">清空</button>
  </div>

  <div id="outputArea">
    <label>输出 / 解码结果</label>
    <textarea id="output" rows="6" readonly placeholder="结果将显示在这里"></textarea>
    <div class="result" id="preview"></div>
  </div>

  <p class="muted">实现说明：
    本工具使用两种零宽字符：<code>U+200B</code>（零宽空格，代表 bit 0）和 <code>U+200C</code>（零宽非连接符，代表 bit 1）。
    在载体文本中会添加一个不可见的标记（prefix）以便检索隐写数据。
  </p>

<script>
// 映射：'0' -> ZWSP, '1' -> ZWNJ
const ZW0 = '\u200B'; // zero width space = bit 0
const ZW1 = '\u200C'; // zero width non-joiner = bit 1
const MARKER = '\u200D\u200D\u200D\u200D'; // 用作前缀标记（连续4个 ZWJ），用于定位隐写数据

function bytesFromString(str){
  return new TextEncoder().encode(str); // UTF-8 bytes
}
function stringFromBytes(bytes){
  return new TextDecoder().decode(new Uint8Array(bytes));
}

function bytesToBits(bytes){
  let bits = '';
  for(let b of bytes){
    let s = b.toString(2).padStart(8,'0');
    bits += s;
  }
  return bits;
}

function bitsToBytes(bits){
  const bytes = [];
  for(let i=0;i<bits.length;i+=8){
    const chunk = bits.slice(i,i+8);
    if(chunk.length<8) break;
    bytes.push(parseInt(chunk,2));
  }
  return new Uint8Array(bytes);
}

function bitsToZeroWidth(bits){
  // 0 -> ZW0, 1 -> ZW1
  return bits.split('').map(b => b==='0'?ZW0:ZW1).join('');
}

function zeroWidthToBits(zs){
  let bits = '';
  for(let ch of zs){
    if(ch===ZW0) bits += '0';
    else if(ch===ZW1) bits += '1';
    else {
      // ignore others
    }
  }
  return bits;
}

function encodeSecret(secret){
  const bytes = bytesFromString(secret);
  const bits = bytesToBits(bytes);
  const zw = bitsToZeroWidth(bits);
  return MARKER + zw; // prefix marker + payload
}

function embedAppend(carrier, secret){
  const payload = encodeSecret(secret);
  return carrier + payload;
}

function embedInterleave(carrier, secret){
  const bytes = bytesFromString(secret);
  const bits = bytesToBits(bytes);
  if(bits.length > carrier.length){
    throw new Error('载体字符数不足以按位插入隐写数据。请使用更长的载体或选择尾部追加方法。');
  }
  let out = '';
  for(let i=0;i<carrier.length;i++){
    out += carrier[i];
    if(i < bits.length){
      out += (bits[i]==='0'?ZW0:ZW1);
    }
  }
  // 标记放在末尾以便解码时快速定位（仍需要MARKER以兼容）
  return out + MARKER;
}

function findPayloadFromText(text){
  // 优先查找 MARKER 后的零宽字符序列
  const idx = text.indexOf(MARKER);
  if(idx === -1) return null;
  // payload 从 idx + MARKER.length 开始，取后续所有零宽 ZW0 / ZW1
  const start = idx + MARKER.length;
  let zs = '';
  for(let i = start; i < text.length; i++){
    const ch = text[i];
    if(ch === ZW0 || ch === ZW1){
      zs += ch;
    } else if(ch === '\u200D' || ch === '\u200E' || ch === '\u200F' || ch === '\uFEFF'){
      // 允许并跳过其他零宽类字符，但如果遇到可见字符则停止
      // 继续 loop
    } else {
      // 不是零宽字符 -> 停止
      break;
    }
  }
  return zs.length?zs:null;
}

function tryDecodeFromInterleaved(text){
  // 从文本每个字符后读取零宽字符，如果存在则收集位
  let bits = '';
  for(let i=0;i<text.length;i++){
    const ch = text[i];
    const next = text[i+1];
    if(next === ZW0) bits += '0';
    else if(next === ZW1) bits += '1';
    // else 忽略
  }
  if(bits.length===0) return null;
  // bits length should be multiple of 8; trim extra
  const bytes = bitsToBytes(bits);
  try{
    return stringFromBytes(bytes);
  }catch(e){
    return null;
  }
}

function decodePayloadFromZS(zs){
  const bits = zeroWidthToBits(zs);
  const bytes = bitsToBytes(bits);
  return stringFromBytes(bytes);
}

// UI wiring
const carrierEl = document.getElementById('carrier');
const secretEl = document.getElementById('secret');
const methodEl = document.getElementById('method');
const outputEl = document.getElementById('output');
const previewEl = document.getElementById('preview');

document.getElementById('encodeBtn').addEventListener('click', ()=>{
  const carrier = carrierEl.value || '';
  const secret = secretEl.value || '';
  const method = methodEl.value;
  if(!secret){
    alert('请输入要隐藏的秘密文本。');
    return;
  }
  try{
    let out = '';
    if(method === 'append') out = embedAppend(carrier, secret);
    else out = embedInterleave(carrier, secret);
    outputEl.value = out;
    // 预览：把零宽字符高亮显示为可见替代（用于调试 / 验证）
    previewEl.textContent = visualizeZeroWidth(out);
  }catch(err){
    alert(err.message);
  }
});

function visualizeZeroWidth(text){
  // 将零宽字符替换为可视符号，便于用户检查
  return text.replace(/\u200B/g,'[ZWSP]').replace(/\u200C/g,'[ZWNJ]').replace(/\u200D/g,'[ZWJ]');
}

document.getElementById('decodeBtn').addEventListener('click', ()=>{
  const carrier = carrierEl.value || outputEl.value || '';
  if(!carrier){ alert('请在载体文本框粘贴含隐写信息的文本，或先生成输出。'); return; }

  // 先尝试基于 MARKER 提取
  const zs = findPayloadFromText(carrier);
  if(zs){
    try{
      const secret = decodePayloadFromZS(zs);
      outputEl.value = '（从 MARKER 解码）\n' + secret;
      previewEl.textContent = visualizeZeroWidth(carrier);
      return;
    }catch(e){
      // fallthrough
    }
  }

  // 再尝试按插入模式解码
  const inter = tryDecodeFromInterleaved(carrier);
  if(inter){
    outputEl.value = '（按插入模式解码）\n' + inter;
    previewEl.textContent = visualizeZeroWidth(carrier);
    return;
  }

  alert('未发现隐写内容或解码失败。请确保载体中包含本工具生成的隐写数据。');
});

document.getElementById('copyBtn').addEventListener('click', ()=>{
  const out = outputEl.value || '';
  if(!out){ alert('没有可以复制的输出。'); return; }
  navigator.clipboard.writeText(out).then(()=>{
    alert('已复制到剪贴板。');
  }).catch(()=>{ alert('复制失败，您的浏览器可能不支持 clipboard API。'); });
});

document.getElementById('clearBtn').addEventListener('click', ()=>{
  carrierEl.value = '';
  secretEl.value = '';
  outputEl.value = '';
  previewEl.textContent = '';
});

</script>
</body>
</html>
